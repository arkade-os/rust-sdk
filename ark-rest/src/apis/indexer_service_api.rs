/*
 * Ark API
 *
 * Combined Ark Service, Indexer, Admin, Signer Manager, and Wallet API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::ContentType;
use super::Error;
use super::configuration;
use crate::apis::ResponseContent;
use crate::models;
use reqwest;
use serde::Deserialize;
use serde::Serialize;
use serde::de::Error as _;

/// struct for typed errors of method [`indexer_service_get_batch_sweep_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexerServiceGetBatchSweepTransactionsError {
    DefaultResponse(models::Status),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indexer_service_get_commitment_tx`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexerServiceGetCommitmentTxError {
    DefaultResponse(models::Status),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indexer_service_get_connectors`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexerServiceGetConnectorsError {
    DefaultResponse(models::Status),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indexer_service_get_forfeit_txs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexerServiceGetForfeitTxsError {
    DefaultResponse(models::Status),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indexer_service_get_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexerServiceGetSubscriptionError {
    DefaultResponse(models::Status),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indexer_service_get_virtual_txs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexerServiceGetVirtualTxsError {
    DefaultResponse(models::Status),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indexer_service_get_vtxo_chain`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexerServiceGetVtxoChainError {
    DefaultResponse(models::Status),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indexer_service_get_vtxo_tree`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexerServiceGetVtxoTreeError {
    DefaultResponse(models::Status),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indexer_service_get_vtxo_tree_leaves`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexerServiceGetVtxoTreeLeavesError {
    DefaultResponse(models::Status),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indexer_service_get_vtxos`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexerServiceGetVtxosError {
    DefaultResponse(models::Status),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indexer_service_subscribe_for_scripts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexerServiceSubscribeForScriptsError {
    DefaultResponse(models::Status),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indexer_service_unsubscribe_for_scripts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexerServiceUnsubscribeForScriptsError {
    DefaultResponse(models::Status),
    UnknownValue(serde_json::Value),
}

/// GetBatchSweepTransactions returns the list of transaction (txid) that swept a given batch
/// output. In most cases the list contains only one txid, meaning that all the amount locked for a
/// vtxo tree has been claimed back. If any of the leaves of the tree have been unrolled onchain
/// before the expiration, the list will contain many txids instead. In a binary tree with 4 or more
/// leaves, 1 unroll causes the server to broadcast 3 txs to sweep the whole rest of tree for
/// example. If a whole vtxo tree has been unrolled onchain, the list of txids for that batch output
/// is empty.
pub async fn indexer_service_get_batch_sweep_transactions(
    configuration: &configuration::Configuration,
    batch_outpoint_period_txid: &str,
    batch_outpoint_period_vout: i32,
) -> Result<
    models::GetBatchSweepTransactionsResponse,
    Error<IndexerServiceGetBatchSweepTransactionsError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_batch_outpoint_period_txid = batch_outpoint_period_txid;
    let p_batch_outpoint_period_vout = batch_outpoint_period_vout;

    let uri_str = format!(
        "{}/v1/indexer/batch/{batch_outpoint_txid}/{batch_outpoint_vout}/sweepTxs",
        configuration.base_path,
        batch_outpoint_txid = crate::apis::urlencode(p_batch_outpoint_period_txid),
        batch_outpoint_vout = p_batch_outpoint_period_vout
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::GetBatchSweepTransactionsResponse`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GetBatchSweepTransactionsResponse`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IndexerServiceGetBatchSweepTransactionsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GetCommitmentTx returns information about a specific commitment transaction identified by the
/// provided txid.
pub async fn indexer_service_get_commitment_tx(
    configuration: &configuration::Configuration,
    txid: &str,
) -> Result<models::GetCommitmentTxResponse, Error<IndexerServiceGetCommitmentTxError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_txid = txid;

    let uri_str = format!(
        "{}/v1/indexer/commitmentTx/{txid}",
        configuration.base_path,
        txid = crate::apis::urlencode(p_txid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::GetCommitmentTxResponse`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GetCommitmentTxResponse`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IndexerServiceGetCommitmentTxError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GetConnectors returns the tree of connectors for the provided commitment transaction. The
/// response includes a list of connector txs with details on the tree posistion and may include
/// pagination information if the results span multiple pages.
pub async fn indexer_service_get_connectors(
    configuration: &configuration::Configuration,
    txid: &str,
    page_period_size: Option<i32>,
    page_period_index: Option<i32>,
) -> Result<models::GetConnectorsResponse, Error<IndexerServiceGetConnectorsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_txid = txid;
    let p_page_period_size = page_period_size;
    let p_page_period_index = page_period_index;

    let uri_str = format!(
        "{}/v1/indexer/commitmentTx/{txid}/connectors",
        configuration.base_path,
        txid = crate::apis::urlencode(p_txid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_period_size {
        req_builder = req_builder.query(&[("page.size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_period_index {
        req_builder = req_builder.query(&[("page.index", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::GetConnectorsResponse`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GetConnectorsResponse`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IndexerServiceGetConnectorsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GetForfeitTxs returns the list of forfeit transactions that were submitted for the provided
/// commitment transaction. The response may include pagination information if the results span
/// multiple pages.
pub async fn indexer_service_get_forfeit_txs(
    configuration: &configuration::Configuration,
    txid: &str,
    page_period_size: Option<i32>,
    page_period_index: Option<i32>,
) -> Result<models::GetForfeitTxsResponse, Error<IndexerServiceGetForfeitTxsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_txid = txid;
    let p_page_period_size = page_period_size;
    let p_page_period_index = page_period_index;

    let uri_str = format!(
        "{}/v1/indexer/commitmentTx/{txid}/forfeitTxs",
        configuration.base_path,
        txid = crate::apis::urlencode(p_txid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_period_size {
        req_builder = req_builder.query(&[("page.size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_period_index {
        req_builder = req_builder.query(&[("page.index", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::GetForfeitTxsResponse`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GetForfeitTxsResponse`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IndexerServiceGetForfeitTxsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GetSubscription is a server-side streaming RPC which allows clients to receive real-time
/// notifications on transactions related to the subscribed vtxo scripts. The subscription can be
/// created or updated by using the SubscribeForScripts and UnsubscribeForScripts RPCs.
pub async fn indexer_service_get_subscription(
    configuration: &configuration::Configuration,
    subscription_id: &str,
) -> Result<models::GetSubscriptionResponse, Error<IndexerServiceGetSubscriptionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_subscription_id = subscription_id;

    let uri_str = format!(
        "{}/v1/indexer/script/subscription/{subscription_id}",
        configuration.base_path,
        subscription_id = crate::apis::urlencode(p_subscription_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::GetSubscriptionResponse`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GetSubscriptionResponse`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IndexerServiceGetSubscriptionError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GetVirtualTxs returns the virtual transactions in hex format for the specified txids. The
/// response may be paginated if the results span multiple pages.
pub async fn indexer_service_get_virtual_txs(
    configuration: &configuration::Configuration,
    txids: Vec<String>,
    page_period_size: Option<i32>,
    page_period_index: Option<i32>,
) -> Result<models::GetVirtualTxsResponse, Error<IndexerServiceGetVirtualTxsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_txids = txids;
    let p_page_period_size = page_period_size;
    let p_page_period_index = page_period_index;

    let uri_str = format!(
        "{}/v1/indexer/virtualTx/{txids}",
        configuration.base_path,
        txids = p_txids.join(",")
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_period_size {
        req_builder = req_builder.query(&[("page.size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_period_index {
        req_builder = req_builder.query(&[("page.index", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::GetVirtualTxsResponse`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GetVirtualTxsResponse`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IndexerServiceGetVirtualTxsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GetVtxoChain returns the the chain of ark txs that starts from spending any vtxo leaf and ends
/// with the creation of the provided vtxo outpoint. The response may be paginated if the results
/// span multiple pages.
pub async fn indexer_service_get_vtxo_chain(
    configuration: &configuration::Configuration,
    outpoint_period_txid: &str,
    outpoint_period_vout: i32,
    page_period_size: Option<i32>,
    page_period_index: Option<i32>,
) -> Result<models::GetVtxoChainResponse, Error<IndexerServiceGetVtxoChainError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_outpoint_period_txid = outpoint_period_txid;
    let p_outpoint_period_vout = outpoint_period_vout;
    let p_page_period_size = page_period_size;
    let p_page_period_index = page_period_index;

    let uri_str = format!(
        "{}/v1/indexer/vtxo/{outpoint_txid}/{outpoint_vout}/chain",
        configuration.base_path,
        outpoint_txid = crate::apis::urlencode(p_outpoint_period_txid),
        outpoint_vout = p_outpoint_period_vout
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_period_size {
        req_builder = req_builder.query(&[("page.size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_period_index {
        req_builder = req_builder.query(&[("page.index", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::GetVtxoChainResponse`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GetVtxoChainResponse`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IndexerServiceGetVtxoChainError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GetVtxoTree returns the vtxo tree for the provided batch outpoint. The response includes a list
/// of txs with details on the tree posistion and may include pagination information if the results
/// span multiple pages.
pub async fn indexer_service_get_vtxo_tree(
    configuration: &configuration::Configuration,
    batch_outpoint_period_txid: &str,
    batch_outpoint_period_vout: i32,
    page_period_size: Option<i32>,
    page_period_index: Option<i32>,
) -> Result<models::GetVtxoTreeResponse, Error<IndexerServiceGetVtxoTreeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_batch_outpoint_period_txid = batch_outpoint_period_txid;
    let p_batch_outpoint_period_vout = batch_outpoint_period_vout;
    let p_page_period_size = page_period_size;
    let p_page_period_index = page_period_index;

    let uri_str = format!(
        "{}/v1/indexer/batch/{batch_outpoint_txid}/{batch_outpoint_vout}/tree",
        configuration.base_path,
        batch_outpoint_txid = crate::apis::urlencode(p_batch_outpoint_period_txid),
        batch_outpoint_vout = p_batch_outpoint_period_vout
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_period_size {
        req_builder = req_builder.query(&[("page.size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_period_index {
        req_builder = req_builder.query(&[("page.index", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::GetVtxoTreeResponse`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GetVtxoTreeResponse`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IndexerServiceGetVtxoTreeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GetVtxoTreeLeaves returns the list of leaves (vtxo outpoints) of the tree(s) for the provided
/// batch outpoint. The response may be paginated if the results span multiple pages.
pub async fn indexer_service_get_vtxo_tree_leaves(
    configuration: &configuration::Configuration,
    batch_outpoint_period_txid: &str,
    batch_outpoint_period_vout: i32,
    page_period_size: Option<i32>,
    page_period_index: Option<i32>,
) -> Result<models::GetVtxoTreeLeavesResponse, Error<IndexerServiceGetVtxoTreeLeavesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_batch_outpoint_period_txid = batch_outpoint_period_txid;
    let p_batch_outpoint_period_vout = batch_outpoint_period_vout;
    let p_page_period_size = page_period_size;
    let p_page_period_index = page_period_index;

    let uri_str = format!(
        "{}/v1/indexer/batch/{batch_outpoint_txid}/{batch_outpoint_vout}/tree/leaves",
        configuration.base_path,
        batch_outpoint_txid = crate::apis::urlencode(p_batch_outpoint_period_txid),
        batch_outpoint_vout = p_batch_outpoint_period_vout
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_period_size {
        req_builder = req_builder.query(&[("page.size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_period_index {
        req_builder = req_builder.query(&[("page.index", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::GetVtxoTreeLeavesResponse`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GetVtxoTreeLeavesResponse`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IndexerServiceGetVtxoTreeLeavesError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GetVtxos returns the list of vtxos based on the provided filter. Vtxos can be retrieved either
/// by addresses or by outpoints, and optionally filtered by spendable or spent only. The response
/// may be paginated if the results span multiple pages.
pub async fn indexer_service_get_vtxos(
    configuration: &configuration::Configuration,
    scripts: Option<Vec<String>>,
    outpoints: Option<Vec<String>>,
    spendable_only: Option<bool>,
    spent_only: Option<bool>,
    recoverable_only: Option<bool>,
    page_period_size: Option<i32>,
    page_period_index: Option<i32>,
) -> Result<models::GetVtxosResponse, Error<IndexerServiceGetVtxosError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_scripts = scripts;
    let p_outpoints = outpoints;
    let p_spendable_only = spendable_only;
    let p_spent_only = spent_only;
    let p_recoverable_only = recoverable_only;
    let p_page_period_size = page_period_size;
    let p_page_period_index = page_period_index;

    let uri_str = format!("{}/v1/indexer/vtxos", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_scripts {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("scripts".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "scripts",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_outpoints {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("outpoints".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "outpoints",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_spendable_only {
        req_builder = req_builder.query(&[("spendableOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_spent_only {
        req_builder = req_builder.query(&[("spentOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recoverable_only {
        req_builder = req_builder.query(&[("recoverableOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_period_size {
        req_builder = req_builder.query(&[("page.size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_period_index {
        req_builder = req_builder.query(&[("page.index", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::GetVtxosResponse`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GetVtxosResponse`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IndexerServiceGetVtxosError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SubscribeForScripts allows to subscribe for tx notifications related to the provided vtxo
/// scripts. It can also be used to update an existing subscribtion by adding new scripts to it.
pub async fn indexer_service_subscribe_for_scripts(
    configuration: &configuration::Configuration,
    subscribe_for_scripts_request: models::SubscribeForScriptsRequest,
) -> Result<models::SubscribeForScriptsResponse, Error<IndexerServiceSubscribeForScriptsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_subscribe_for_scripts_request = subscribe_for_scripts_request;

    let uri_str = format!("{}/v1/indexer/script/subscribe", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_subscribe_for_scripts_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::SubscribeForScriptsResponse`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SubscribeForScriptsResponse`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IndexerServiceSubscribeForScriptsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UnsubscribeForScripts allows to remove scripts from an existing subscription.
pub async fn indexer_service_unsubscribe_for_scripts(
    configuration: &configuration::Configuration,
    unsubscribe_for_scripts_request: models::UnsubscribeForScriptsRequest,
) -> Result<serde_json::Value, Error<IndexerServiceUnsubscribeForScriptsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_unsubscribe_for_scripts_request = unsubscribe_for_scripts_request;

    let uri_str = format!("{}/v1/indexer/script/unsubscribe", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_unsubscribe_for_scripts_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IndexerServiceUnsubscribeForScriptsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
