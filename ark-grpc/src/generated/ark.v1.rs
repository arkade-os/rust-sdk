// This file is @generated by prost-build.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LoadSignerRequest {
    #[prost(oneof = "load_signer_request::Config", tags = "1, 2")]
    pub config: ::core::option::Option<load_signer_request::Config>,
}
/// Nested message and enum types in `LoadSignerRequest`.
pub mod load_signer_request {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Config {
        #[prost(string, tag = "1")]
        SignerUrl(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        SignerPrivateKey(::prost::alloc::string::String),
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LoadSignerResponse {}
/// Generated client implementations.
pub mod signer_manager_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct SignerManagerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SignerManagerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SignerManagerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SignerManagerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SignerManagerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn load_signer(
            &mut self,
            request: impl tonic::IntoRequest<super::LoadSignerRequest>,
        ) -> std::result::Result<tonic::Response<super::LoadSignerResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.SignerManagerService/LoadSigner");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.SignerManagerService", "LoadSigner"));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Outpoint {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub vout: u32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Input {
    #[prost(message, optional, tag = "1")]
    pub outpoint: ::core::option::Option<Outpoint>,
    #[prost(message, optional, tag = "2")]
    pub taproot_tree: ::core::option::Option<Tapscripts>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Vtxo {
    #[prost(message, optional, tag = "1")]
    pub outpoint: ::core::option::Option<Outpoint>,
    #[prost(uint64, tag = "2")]
    pub amount: u64,
    #[prost(string, tag = "3")]
    pub script: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub created_at: i64,
    #[prost(int64, tag = "5")]
    pub expires_at: i64,
    #[prost(string, repeated, tag = "6")]
    pub commitment_txids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "7")]
    pub is_preconfirmed: bool,
    #[prost(bool, tag = "8")]
    pub is_swept: bool,
    #[prost(bool, tag = "9")]
    pub is_unrolled: bool,
    #[prost(bool, tag = "10")]
    pub is_spent: bool,
    #[prost(string, tag = "11")]
    pub spent_by: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub settled_by: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub ark_txid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TxData {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tx: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxNotification {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tx: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub spent_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
    #[prost(message, repeated, tag = "4")]
    pub spendable_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
    /// This field is set only in case of offchain tx.
    ///
    /// key: outpoint, value: checkpoint txid
    #[prost(map = "string, message", tag = "5")]
    pub checkpoint_txs: ::std::collections::HashMap<::prost::alloc::string::String, TxData>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Tapscripts {
    #[prost(string, repeated, tag = "1")]
    pub scripts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Intent {
    #[prost(string, tag = "1")]
    pub proof: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ScheduledSession {
    #[prost(int64, tag = "1")]
    pub next_start_time: i64,
    #[prost(int64, tag = "2")]
    pub next_end_time: i64,
    #[prost(int64, tag = "3")]
    pub period: i64,
    #[prost(int64, tag = "4")]
    pub duration: i64,
    #[prost(message, optional, tag = "5")]
    pub fees: ::core::option::Option<FeeInfo>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FeeInfo {
    #[prost(message, optional, tag = "1")]
    pub intent_fee: ::core::option::Option<IntentFeeInfo>,
    #[prost(string, tag = "2")]
    pub tx_fee_rate: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IntentFeeInfo {
    #[prost(string, tag = "1")]
    pub offchain_input: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub offchain_output: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub onchain_input: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub onchain_output: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PendingTx {
    #[prost(string, tag = "1")]
    pub ark_txid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub final_ark_tx: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub signed_checkpoint_txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeprecatedSigner {
    #[prost(string, tag = "1")]
    pub pubkey: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub cutoff_date: i64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchStartedEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub intent_id_hashes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "3")]
    pub batch_expiry: i64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchFinalizationEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub commitment_tx: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchFinalizedEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub commitment_txid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchFailedEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TreeSigningStartedEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub cosigners_pubkeys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub unsigned_commitment_tx: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreeNoncesAggregatedEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "2")]
    pub tree_nonces:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreeNoncesEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub topic: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub txid: ::prost::alloc::string::String,
    /// pubkey -> musig2 public nonce
    #[prost(map = "string, string", tag = "4")]
    pub nonces:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreeTxEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub topic: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub batch_index: i32,
    #[prost(string, tag = "4")]
    pub txid: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub tx: ::prost::alloc::string::String,
    /// output index -> child txid
    #[prost(map = "uint32, string", tag = "6")]
    pub children: ::std::collections::HashMap<u32, ::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TreeSignatureEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub topic: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub batch_index: i32,
    #[prost(string, tag = "4")]
    pub txid: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub signature: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Heartbeat {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorDetails {
    #[prost(int32, tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "4")]
    pub metadata:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetInfoRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInfoResponse {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub signer_pubkey: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub forfeit_pubkey: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub forfeit_address: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub checkpoint_tapscript: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub network: ::prost::alloc::string::String,
    #[prost(int64, tag = "7")]
    pub session_duration: i64,
    #[prost(int64, tag = "8")]
    pub unilateral_exit_delay: i64,
    #[prost(int64, tag = "9")]
    pub boarding_exit_delay: i64,
    #[prost(int64, tag = "10")]
    pub utxo_min_amount: i64,
    /// -1 means no limit (default), 0 means boarding not allowed
    #[prost(int64, tag = "11")]
    pub utxo_max_amount: i64,
    #[prost(int64, tag = "12")]
    pub vtxo_min_amount: i64,
    /// -1 means no limit (default)
    #[prost(int64, tag = "13")]
    pub vtxo_max_amount: i64,
    #[prost(int64, tag = "14")]
    pub dust: i64,
    #[prost(message, optional, tag = "15")]
    pub fees: ::core::option::Option<FeeInfo>,
    #[prost(message, optional, tag = "16")]
    pub scheduled_session: ::core::option::Option<ScheduledSession>,
    #[prost(message, repeated, tag = "17")]
    pub deprecated_signers: ::prost::alloc::vec::Vec<DeprecatedSigner>,
    #[prost(map = "string, string", tag = "18")]
    pub service_status:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(string, tag = "19")]
    pub digest: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RegisterIntentRequest {
    /// an intent proof that embeds the outpoints to be spent and new ones to be created, as well
    /// as the proof of funds.
    #[prost(message, optional, tag = "1")]
    pub intent: ::core::option::Option<Intent>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RegisterIntentResponse {
    #[prost(string, tag = "1")]
    pub intent_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteIntentRequest {
    /// an intent proof that includes any of the inputs of the intent to be deleted to prove the
    /// ownership of that intent.
    #[prost(message, optional, tag = "1")]
    pub intent: ::core::option::Option<Intent>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteIntentResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConfirmRegistrationRequest {
    #[prost(string, tag = "1")]
    pub intent_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConfirmRegistrationResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTreeNoncesRequest {
    #[prost(string, tag = "1")]
    pub batch_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pubkey: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub tree_nonces:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubmitTreeNoncesResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTreeSignaturesRequest {
    #[prost(string, tag = "1")]
    pub batch_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pubkey: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub tree_signatures:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubmitTreeSignaturesResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubmitSignedForfeitTxsRequest {
    /// Forfeit txs signed by the user.
    #[prost(string, repeated, tag = "1")]
    pub signed_forfeit_txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The user has to sign also the commitment tx if he registered a boarding UTXO.
    #[prost(string, tag = "2")]
    pub signed_commitment_tx: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubmitSignedForfeitTxsResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetEventStreamRequest {
    #[prost(string, repeated, tag = "1")]
    pub topics: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventStreamResponse {
    #[prost(
        oneof = "get_event_stream_response::Event",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10"
    )]
    pub event: ::core::option::Option<get_event_stream_response::Event>,
}
/// Nested message and enum types in `GetEventStreamResponse`.
pub mod get_event_stream_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        BatchStarted(super::BatchStartedEvent),
        #[prost(message, tag = "2")]
        BatchFinalization(super::BatchFinalizationEvent),
        #[prost(message, tag = "3")]
        BatchFinalized(super::BatchFinalizedEvent),
        #[prost(message, tag = "4")]
        BatchFailed(super::BatchFailedEvent),
        #[prost(message, tag = "5")]
        TreeSigningStarted(super::TreeSigningStartedEvent),
        #[prost(message, tag = "6")]
        TreeNoncesAggregated(super::TreeNoncesAggregatedEvent),
        #[prost(message, tag = "7")]
        TreeTx(super::TreeTxEvent),
        #[prost(message, tag = "8")]
        TreeSignature(super::TreeSignatureEvent),
        #[prost(message, tag = "9")]
        TreeNonces(super::TreeNoncesEvent),
        #[prost(message, tag = "10")]
        Heartbeat(super::Heartbeat),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubmitTxRequest {
    #[prost(string, tag = "1")]
    pub signed_ark_tx: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub checkpoint_txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubmitTxResponse {
    #[prost(string, tag = "1")]
    pub ark_txid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub final_ark_tx: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub signed_checkpoint_txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FinalizeTxRequest {
    #[prost(string, tag = "1")]
    pub ark_txid: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub final_checkpoint_txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FinalizeTxResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPendingTxRequest {
    #[prost(message, optional, tag = "1")]
    pub intent: ::core::option::Option<Intent>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPendingTxResponse {
    #[prost(message, repeated, tag = "1")]
    pub pending_txs: ::prost::alloc::vec::Vec<PendingTx>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTransactionsStreamRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionsStreamResponse {
    #[prost(oneof = "get_transactions_stream_response::Data", tags = "1, 2, 3")]
    pub data: ::core::option::Option<get_transactions_stream_response::Data>,
}
/// Nested message and enum types in `GetTransactionsStreamResponse`.
pub mod get_transactions_stream_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = "1")]
        CommitmentTx(super::TxNotification),
        #[prost(message, tag = "2")]
        ArkTx(super::TxNotification),
        #[prost(message, tag = "3")]
        Heartbeat(super::Heartbeat),
    }
}
/// Generated client implementations.
pub mod ark_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct ArkServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ArkServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ArkServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ArkServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ArkServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// GetInfo returns information and parameters of the server.
        pub async fn get_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInfoRequest>,
        ) -> std::result::Result<tonic::Response<super::GetInfoResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/GetInfo");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "GetInfo"));
            self.inner.unary(req, path, codec).await
        }
        /// RegisterIntent allows to register a new intent that will be eventually selected by the
        /// server for a particular batch.
        /// The client should provide a BIP-322 message with the intent information, and the server
        /// should respond with an intent id.
        pub async fn register_intent(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterIntentRequest>,
        ) -> std::result::Result<tonic::Response<super::RegisterIntentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/RegisterIntent");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "RegisterIntent"));
            self.inner.unary(req, path, codec).await
        }
        /// DeleteIntent removes a previously registered intent from the server.
        /// The client should provide the BIP-322 signature and message including any of the vtxos
        /// used in the registered intent to prove its ownership.
        /// The server should delete the intent and return success.
        pub async fn delete_intent(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIntentRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteIntentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/DeleteIntent");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "DeleteIntent"));
            self.inner.unary(req, path, codec).await
        }
        /// ConfirmRegistration allows a client that has been selected for the next batch to confirm
        /// its participation by revealing the intent id.
        pub async fn confirm_registration(
            &mut self,
            request: impl tonic::IntoRequest<super::ConfirmRegistrationRequest>,
        ) -> std::result::Result<tonic::Response<super::ConfirmRegistrationResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ArkService/ConfirmRegistration");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "ConfirmRegistration"));
            self.inner.unary(req, path, codec).await
        }
        /// SubmitTreeNonces allows a cosigner to submit the tree nonces for the musig2 session of a
        /// given batch.
        /// The client should provide the batch id, the cosigner public key, and the tree nonces.
        /// The server should verify the cosigner public key and the nonces, and store them for
        /// later aggregation once nonces from all clients are collected.
        pub async fn submit_tree_nonces(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitTreeNoncesRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitTreeNoncesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/SubmitTreeNonces");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "SubmitTreeNonces"));
            self.inner.unary(req, path, codec).await
        }
        /// SubmitTreeSignatures allows a cosigner to submit the tree signatures for the musig2
        /// session of a given batch.
        /// The client should provide the batch id, the cosigner public key, and the tree
        /// signatures. The server should verify the cosigner public key and the signatures,
        /// and store them for later aggregation once signatures from all clients are
        /// collected.
        pub async fn submit_tree_signatures(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitTreeSignaturesRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitTreeSignaturesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ArkService/SubmitTreeSignatures");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "SubmitTreeSignatures"));
            self.inner.unary(req, path, codec).await
        }
        /// SubmitSignedForfeitTxs allows a client to submit signed forfeit transactions and/or
        /// signed commitment transaction (in case of onboarding).
        /// The server should verify the signed txs and return success.
        pub async fn submit_signed_forfeit_txs(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitSignedForfeitTxsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitSignedForfeitTxsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ArkService/SubmitSignedForfeitTxs");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.ArkService",
                "SubmitSignedForfeitTxs",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetEventStream is a server-side streaming RPC that allows clients to receive a stream of
        /// events related to batch processing.
        /// Clients should use this stream as soon as they are ready to join a batch and can listen
        /// for various events such as batch start, batch finalization, and other related
        /// activities. The server pushes these events to the client in real-time as soon as
        /// its ready to move to the next phase of the batch processing.
        pub async fn get_event_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEventStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetEventStreamResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/GetEventStream");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "GetEventStream"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// SubmitTx is the first leg of the process of spending vtxos offchain and allows a client
        /// to submit a signed Ark transaction and the unsigned checkpoint transactions.
        /// The server should verify the signed transactions and return the fully signed Ark tx and
        /// the signed checkpoint txs.
        pub async fn submit_tx(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitTxRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitTxResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/SubmitTx");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "SubmitTx"));
            self.inner.unary(req, path, codec).await
        }
        /// FinalizeTx is the last lef of the process of spending vtxos offchain and allows a client
        /// to submit the fully signed checkpoint txs for the provided Ark txid .
        /// The server verifies the signed checkpoint transactions and returns success if everything
        /// is valid.
        pub async fn finalize_tx(
            &mut self,
            request: impl tonic::IntoRequest<super::FinalizeTxRequest>,
        ) -> std::result::Result<tonic::Response<super::FinalizeTxResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/FinalizeTx");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "FinalizeTx"));
            self.inner.unary(req, path, codec).await
        }
        /// GetPendingTx returns not finalized transaction(s) for a given set of inputs.
        /// the client should provide a BIP322 proof of ownership of the inputs
        pub async fn get_pending_tx(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPendingTxRequest>,
        ) -> std::result::Result<tonic::Response<super::GetPendingTxResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/GetPendingTx");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "GetPendingTx"));
            self.inner.unary(req, path, codec).await
        }
        /// GetTransactionsStream is a server-side streaming RPC that allows clients to receive
        /// notifications in real-time about any commitment tx or ark tx processed and finalized by
        /// the server.
        /// NOTE: the stream doesn't have history support, therefore returns only txs from the
        /// moment it's opened until it's closed.
        pub async fn get_transactions_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionsStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetTransactionsStreamResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ArkService/GetTransactionsStream");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.ArkService",
                "GetTransactionsStream",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GenSeedRequest {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GenSeedResponse {
    #[prost(string, tag = "1")]
    pub seed: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateRequest {
    #[prost(string, tag = "1")]
    pub seed: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RestoreRequest {
    #[prost(string, tag = "1")]
    pub seed: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub gap_limit: u64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RestoreResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnlockRequest {
    #[prost(string, tag = "1")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnlockResponse {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LockRequest {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LockResponse {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetStatusRequest {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetStatusResponse {
    #[prost(bool, tag = "1")]
    pub initialized: bool,
    #[prost(bool, tag = "2")]
    pub unlocked: bool,
    #[prost(bool, tag = "3")]
    pub synced: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeriveAddressRequest {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeriveAddressResponse {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBalanceRequest {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Balance {
    #[prost(string, tag = "1")]
    pub locked: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub available: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBalanceResponse {
    #[prost(message, optional, tag = "1")]
    pub main_account: ::core::option::Option<Balance>,
    #[prost(message, optional, tag = "2")]
    pub connectors_account: ::core::option::Option<Balance>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WithdrawRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub amount: u64,
    /// if all=true, amount is ignored and all available balance is withdrawn including connectors
    /// account funds must be used carefully to not make connectors utxos unspendable, making
    /// forfeit txs invalid
    #[prost(bool, tag = "3")]
    pub all: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WithdrawResponse {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod wallet_initializer_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct WalletInitializerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WalletInitializerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WalletInitializerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WalletInitializerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            WalletInitializerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn gen_seed(
            &mut self,
            request: impl tonic::IntoRequest<super::GenSeedRequest>,
        ) -> std::result::Result<tonic::Response<super::GenSeedResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/GenSeed");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.WalletInitializerService",
                "GenSeed",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/Create");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletInitializerService", "Create"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn restore(
            &mut self,
            request: impl tonic::IntoRequest<super::RestoreRequest>,
        ) -> std::result::Result<tonic::Response<super::RestoreResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/Restore");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.WalletInitializerService",
                "Restore",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn unlock(
            &mut self,
            request: impl tonic::IntoRequest<super::UnlockRequest>,
        ) -> std::result::Result<tonic::Response<super::UnlockResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/Unlock");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletInitializerService", "Unlock"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStatusRequest>,
        ) -> std::result::Result<tonic::Response<super::GetStatusResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/GetStatus");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.WalletInitializerService",
                "GetStatus",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod wallet_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct WalletServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WalletServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WalletServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WalletServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            WalletServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn lock(
            &mut self,
            request: impl tonic::IntoRequest<super::LockRequest>,
        ) -> std::result::Result<tonic::Response<super::LockResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.WalletService/Lock");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletService", "Lock"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn derive_address(
            &mut self,
            request: impl tonic::IntoRequest<super::DeriveAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::DeriveAddressResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.WalletService/DeriveAddress");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletService", "DeriveAddress"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBalanceRequest>,
        ) -> std::result::Result<tonic::Response<super::GetBalanceResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.WalletService/GetBalance");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletService", "GetBalance"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn withdraw(
            &mut self,
            request: impl tonic::IntoRequest<super::WithdrawRequest>,
        ) -> std::result::Result<tonic::Response<super::WithdrawResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.WalletService/Withdraw");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletService", "Withdraw"));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCommitmentTxRequest {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCommitmentTxResponse {
    #[prost(int64, tag = "1")]
    pub started_at: i64,
    #[prost(int64, tag = "2")]
    pub ended_at: i64,
    #[prost(map = "uint32, message", tag = "3")]
    pub batches: ::std::collections::HashMap<u32, IndexerBatch>,
    #[prost(uint64, tag = "4")]
    pub total_input_amount: u64,
    #[prost(int32, tag = "5")]
    pub total_input_vtxos: i32,
    #[prost(uint64, tag = "6")]
    pub total_output_amount: u64,
    #[prost(int32, tag = "7")]
    pub total_output_vtxos: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetForfeitTxsRequest {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetForfeitTxsResponse {
    #[prost(string, repeated, tag = "1")]
    pub txids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetConnectorsRequest {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectorsResponse {
    #[prost(message, repeated, tag = "1")]
    pub connectors: ::prost::alloc::vec::Vec<IndexerNode>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetVtxoTreeRequest {
    #[prost(message, optional, tag = "1")]
    pub batch_outpoint: ::core::option::Option<IndexerOutpoint>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxoTreeResponse {
    #[prost(message, repeated, tag = "1")]
    pub vtxo_tree: ::prost::alloc::vec::Vec<IndexerNode>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetVtxoTreeLeavesRequest {
    #[prost(message, optional, tag = "1")]
    pub batch_outpoint: ::core::option::Option<IndexerOutpoint>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxoTreeLeavesResponse {
    #[prost(message, repeated, tag = "1")]
    pub leaves: ::prost::alloc::vec::Vec<IndexerOutpoint>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetVtxosRequest {
    /// Either specify a list of vtxo scripts.
    #[prost(string, repeated, tag = "1")]
    pub scripts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Or specify a list of vtxo outpoints. The 2 filters are mutually exclusive.
    #[prost(string, repeated, tag = "2")]
    pub outpoints: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Retrieve only spendable vtxos
    #[prost(bool, tag = "3")]
    pub spendable_only: bool,
    /// Retrieve only spent vtxos.
    #[prost(bool, tag = "4")]
    pub spent_only: bool,
    /// Retrieve only recoverable vtxos (notes, subdust or swept vtxos).
    /// The 3 filters are mutually exclusive,
    #[prost(bool, tag = "5")]
    pub recoverable_only: bool,
    #[prost(message, optional, tag = "6")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxosResponse {
    #[prost(message, repeated, tag = "1")]
    pub vtxos: ::prost::alloc::vec::Vec<IndexerVtxo>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetVtxoChainRequest {
    #[prost(message, optional, tag = "1")]
    pub outpoint: ::core::option::Option<IndexerOutpoint>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxoChainResponse {
    #[prost(message, repeated, tag = "1")]
    pub chain: ::prost::alloc::vec::Vec<IndexerChain>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetVirtualTxsRequest {
    #[prost(string, repeated, tag = "1")]
    pub txids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetVirtualTxsResponse {
    #[prost(string, repeated, tag = "1")]
    pub txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBatchSweepTransactionsRequest {
    #[prost(message, optional, tag = "1")]
    pub batch_outpoint: ::core::option::Option<IndexerOutpoint>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBatchSweepTransactionsResponse {
    #[prost(string, repeated, tag = "1")]
    pub swept_by: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IndexerBatch {
    #[prost(uint64, tag = "1")]
    pub total_output_amount: u64,
    #[prost(int32, tag = "2")]
    pub total_output_vtxos: i32,
    #[prost(int64, tag = "3")]
    pub expires_at: i64,
    #[prost(bool, tag = "4")]
    pub swept: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IndexerOutpoint {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub vout: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerNode {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    /// vout -> txid
    #[prost(map = "uint32, string", tag = "2")]
    pub children: ::std::collections::HashMap<u32, ::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IndexerVtxo {
    #[prost(message, optional, tag = "1")]
    pub outpoint: ::core::option::Option<IndexerOutpoint>,
    #[prost(int64, tag = "2")]
    pub created_at: i64,
    #[prost(int64, tag = "3")]
    pub expires_at: i64,
    #[prost(uint64, tag = "4")]
    pub amount: u64,
    #[prost(string, tag = "5")]
    pub script: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub is_preconfirmed: bool,
    #[prost(bool, tag = "7")]
    pub is_swept: bool,
    #[prost(bool, tag = "8")]
    pub is_unrolled: bool,
    #[prost(bool, tag = "9")]
    pub is_spent: bool,
    #[prost(string, tag = "10")]
    pub spent_by: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "11")]
    pub commitment_txids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "12")]
    pub settled_by: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub ark_txid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IndexerChain {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub expires_at: i64,
    #[prost(enumeration = "IndexerChainedTxType", tag = "3")]
    pub r#type: i32,
    /// txids of the transactions in the chain used as input of the current tx
    #[prost(string, repeated, tag = "4")]
    pub spends: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IndexerTxHistoryRecord {
    #[prost(enumeration = "IndexerTxType", tag = "3")]
    pub r#type: i32,
    #[prost(uint64, tag = "4")]
    pub amount: u64,
    #[prost(int64, tag = "5")]
    pub created_at: i64,
    #[prost(bool, tag = "6")]
    pub is_settled: bool,
    #[prost(string, tag = "7")]
    pub settled_by: ::prost::alloc::string::String,
    #[prost(oneof = "indexer_tx_history_record::Key", tags = "1, 2")]
    pub key: ::core::option::Option<indexer_tx_history_record::Key>,
}
/// Nested message and enum types in `IndexerTxHistoryRecord`.
pub mod indexer_tx_history_record {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Key {
        #[prost(string, tag = "1")]
        CommitmentTxid(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        VirtualTxid(::prost::alloc::string::String),
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IndexerPageRequest {
    #[prost(int32, tag = "1")]
    pub size: i32,
    #[prost(int32, tag = "2")]
    pub index: i32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IndexerPageResponse {
    #[prost(int32, tag = "1")]
    pub current: i32,
    #[prost(int32, tag = "2")]
    pub next: i32,
    #[prost(int32, tag = "3")]
    pub total: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubscribeForScriptsRequest {
    #[prost(string, repeated, tag = "1")]
    pub scripts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If set, update an existing subscription
    #[prost(string, tag = "2")]
    pub subscription_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubscribeForScriptsResponse {
    #[prost(string, tag = "1")]
    pub subscription_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnsubscribeForScriptsRequest {
    #[prost(string, tag = "1")]
    pub subscription_id: ::prost::alloc::string::String,
    /// If empty, unsubscribe all scripts
    #[prost(string, repeated, tag = "2")]
    pub scripts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnsubscribeForScriptsResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSubscriptionRequest {
    #[prost(string, tag = "1")]
    pub subscription_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSubscriptionResponse {
    #[prost(oneof = "get_subscription_response::Data", tags = "1, 2")]
    pub data: ::core::option::Option<get_subscription_response::Data>,
}
/// Nested message and enum types in `GetSubscriptionResponse`.
pub mod get_subscription_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = "1")]
        Heartbeat(super::IndexerHeartbeat),
        #[prost(message, tag = "2")]
        Event(super::IndexerSubscriptionEvent),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IndexerTxData {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tx: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IndexerHeartbeat {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerSubscriptionEvent {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub scripts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub new_vtxos: ::prost::alloc::vec::Vec<IndexerVtxo>,
    #[prost(message, repeated, tag = "4")]
    pub spent_vtxos: ::prost::alloc::vec::Vec<IndexerVtxo>,
    #[prost(string, tag = "5")]
    pub tx: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "6")]
    pub checkpoint_txs: ::std::collections::HashMap<::prost::alloc::string::String, IndexerTxData>,
    #[prost(message, repeated, tag = "7")]
    pub swept_vtxos: ::prost::alloc::vec::Vec<IndexerVtxo>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexerTxType {
    Unspecified = 0,
    Received = 1,
    Sent = 2,
}
impl IndexerTxType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INDEXER_TX_TYPE_UNSPECIFIED",
            Self::Received => "INDEXER_TX_TYPE_RECEIVED",
            Self::Sent => "INDEXER_TX_TYPE_SENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INDEXER_TX_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "INDEXER_TX_TYPE_RECEIVED" => Some(Self::Received),
            "INDEXER_TX_TYPE_SENT" => Some(Self::Sent),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexerChainedTxType {
    Unspecified = 0,
    Commitment = 1,
    Ark = 2,
    Tree = 3,
    Checkpoint = 4,
}
impl IndexerChainedTxType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INDEXER_CHAINED_TX_TYPE_UNSPECIFIED",
            Self::Commitment => "INDEXER_CHAINED_TX_TYPE_COMMITMENT",
            Self::Ark => "INDEXER_CHAINED_TX_TYPE_ARK",
            Self::Tree => "INDEXER_CHAINED_TX_TYPE_TREE",
            Self::Checkpoint => "INDEXER_CHAINED_TX_TYPE_CHECKPOINT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INDEXER_CHAINED_TX_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "INDEXER_CHAINED_TX_TYPE_COMMITMENT" => Some(Self::Commitment),
            "INDEXER_CHAINED_TX_TYPE_ARK" => Some(Self::Ark),
            "INDEXER_CHAINED_TX_TYPE_TREE" => Some(Self::Tree),
            "INDEXER_CHAINED_TX_TYPE_CHECKPOINT" => Some(Self::Checkpoint),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod indexer_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct IndexerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl IndexerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> IndexerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> IndexerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            IndexerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// GetCommitmentTx returns information about a specific commitment transaction identified
        /// by the provided txid.
        pub async fn get_commitment_tx(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCommitmentTxRequest>,
        ) -> std::result::Result<tonic::Response<super::GetCommitmentTxResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetCommitmentTx");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetCommitmentTx"));
            self.inner.unary(req, path, codec).await
        }
        /// GetForfeitTxs returns the list of forfeit transactions that were submitted for the
        /// provided commitment transaction.
        /// The response may include pagination information if the results span multiple pages.
        pub async fn get_forfeit_txs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetForfeitTxsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetForfeitTxsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetForfeitTxs");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetForfeitTxs"));
            self.inner.unary(req, path, codec).await
        }
        /// GetConnectors returns the tree of connectors for the provided commitment transaction.
        /// The response includes a list of connector txs with details on the tree posistion and may
        /// include pagination information if the results span multiple pages.
        pub async fn get_connectors(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConnectorsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetConnectorsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetConnectors");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetConnectors"));
            self.inner.unary(req, path, codec).await
        }
        /// GetVtxoTree returns the vtxo tree for the provided batch outpoint.
        /// The response includes a list of txs with details on the tree posistion and may
        /// include pagination information if the results span multiple pages.
        pub async fn get_vtxo_tree(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVtxoTreeRequest>,
        ) -> std::result::Result<tonic::Response<super::GetVtxoTreeResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetVtxoTree");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetVtxoTree"));
            self.inner.unary(req, path, codec).await
        }
        /// GetVtxoTreeLeaves returns the list of leaves (vtxo outpoints) of the tree(s) for the
        /// provided batch outpoint.
        /// The response may be paginated if the results span multiple pages.
        pub async fn get_vtxo_tree_leaves(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVtxoTreeLeavesRequest>,
        ) -> std::result::Result<tonic::Response<super::GetVtxoTreeLeavesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetVtxoTreeLeaves");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.IndexerService",
                "GetVtxoTreeLeaves",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetVtxos returns the list of vtxos based on the provided filter. Vtxos can be retrieved
        /// either by addresses or by outpoints, and optionally filtered by spendable or
        /// spent only. The response may be paginated if the results span multiple pages.
        pub async fn get_vtxos(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVtxosRequest>,
        ) -> std::result::Result<tonic::Response<super::GetVtxosResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetVtxos");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetVtxos"));
            self.inner.unary(req, path, codec).await
        }
        /// GetVtxoChain returns the the chain of ark txs that starts from spending any vtxo leaf
        /// and ends with the creation of the provided vtxo outpoint.
        /// The response may be paginated if the results span multiple pages.
        pub async fn get_vtxo_chain(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVtxoChainRequest>,
        ) -> std::result::Result<tonic::Response<super::GetVtxoChainResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetVtxoChain");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetVtxoChain"));
            self.inner.unary(req, path, codec).await
        }
        /// GetVirtualTxs returns the virtual transactions in hex format for the specified txids.
        /// The response may be paginated if the results span multiple pages.
        pub async fn get_virtual_txs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVirtualTxsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetVirtualTxsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetVirtualTxs");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetVirtualTxs"));
            self.inner.unary(req, path, codec).await
        }
        /// GetBatchSweepTransactions returns the list of transaction (txid) that swept a given
        /// batch output.
        /// In most cases the list contains only one txid, meaning that all the amount locked for a
        /// vtxo tree has been claimed back.
        /// If any of the leaves of the tree have been unrolled onchain before the expiration, the
        /// list will contain many txids instead.
        /// In a binary tree with 4 or more leaves, 1 unroll causes the server to broadcast 3 txs to
        /// sweep the whole rest of tree for example.
        /// If a whole vtxo tree has been unrolled onchain, the list of txids for that batch output
        /// is empty.
        pub async fn get_batch_sweep_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBatchSweepTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBatchSweepTransactionsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ark.v1.IndexerService/GetBatchSweepTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.IndexerService",
                "GetBatchSweepTransactions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// SubscribeForScripts allows to subscribe for tx notifications related to the provided
        /// vtxo scripts. It can also be used to update an existing subscribtion by adding
        /// new scripts to it.
        pub async fn subscribe_for_scripts(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeForScriptsRequest>,
        ) -> std::result::Result<tonic::Response<super::SubscribeForScriptsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/SubscribeForScripts");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.IndexerService",
                "SubscribeForScripts",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// UnsubscribeForScripts allows to remove scripts from an existing subscription.
        pub async fn unsubscribe_for_scripts(
            &mut self,
            request: impl tonic::IntoRequest<super::UnsubscribeForScriptsRequest>,
        ) -> std::result::Result<tonic::Response<super::UnsubscribeForScriptsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ark.v1.IndexerService/UnsubscribeForScripts",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.IndexerService",
                "UnsubscribeForScripts",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetSubscription is a server-side streaming RPC which allows clients to receive real-time
        /// notifications on transactions related to the subscribed vtxo scripts.
        /// The subscription can be created or updated by using the SubscribeForScripts and
        /// UnsubscribeForScripts RPCs.
        pub async fn get_subscription(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSubscriptionRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetSubscriptionResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetSubscription");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetSubscription"));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetScheduledSweepRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetScheduledSweepResponse {
    #[prost(message, repeated, tag = "1")]
    pub sweeps: ::prost::alloc::vec::Vec<ScheduledSweep>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRoundDetailsRequest {
    #[prost(string, tag = "1")]
    pub round_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRoundDetailsResponse {
    #[prost(string, tag = "1")]
    pub round_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub started_at: i64,
    #[prost(int64, tag = "3")]
    pub ended_at: i64,
    #[prost(string, tag = "4")]
    pub commitment_txid: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub forfeited_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub total_vtxos_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub total_exit_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub total_fee_amount: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "9")]
    pub inputs_vtxos: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "10")]
    pub outputs_vtxos: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "11")]
    pub exit_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRoundsRequest {
    #[prost(int64, tag = "1")]
    pub after: i64,
    #[prost(int64, tag = "2")]
    pub before: i64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRoundsResponse {
    #[prost(string, repeated, tag = "1")]
    pub rounds: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateNoteRequest {
    #[prost(uint32, tag = "1")]
    pub amount: u32,
    #[prost(uint32, tag = "2")]
    pub quantity: u32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateNoteResponse {
    #[prost(string, repeated, tag = "1")]
    pub notes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetScheduledSessionConfigRequest {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetScheduledSessionConfigResponse {
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<ScheduledSessionConfig>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateScheduledSessionConfigRequest {
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<ScheduledSessionConfig>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateScheduledSessionConfigResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListIntentsRequest {
    #[prost(string, repeated, tag = "1")]
    pub intent_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIntentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub intents: ::prost::alloc::vec::Vec<IntentInfo>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteIntentsRequest {
    #[prost(string, repeated, tag = "1")]
    pub intent_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteIntentsResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetConvictionsRequest {
    #[prost(string, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConvictionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub convictions: ::prost::alloc::vec::Vec<Conviction>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetConvictionsInRangeRequest {
    /// Unix timestamp
    #[prost(int64, tag = "1")]
    pub from: i64,
    /// Unix timestamp
    #[prost(int64, tag = "2")]
    pub to: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConvictionsInRangeResponse {
    #[prost(message, repeated, tag = "1")]
    pub convictions: ::prost::alloc::vec::Vec<Conviction>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetConvictionsByRoundRequest {
    #[prost(string, tag = "1")]
    pub round_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConvictionsByRoundResponse {
    #[prost(message, repeated, tag = "1")]
    pub convictions: ::prost::alloc::vec::Vec<Conviction>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetActiveScriptConvictionsRequest {
    #[prost(string, tag = "1")]
    pub script: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActiveScriptConvictionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub convictions: ::prost::alloc::vec::Vec<Conviction>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PardonConvictionRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PardonConvictionResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BanScriptRequest {
    #[prost(string, tag = "1")]
    pub script: ::prost::alloc::string::String,
    /// 0 = permanent ban
    #[prost(int64, tag = "2")]
    pub ban_duration: i64,
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BanScriptResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RevokeAuthRequest {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RevokeAuthResponse {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SweepableOutput {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub vout: u32,
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub scheduled_at: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduledSweep {
    #[prost(string, tag = "1")]
    pub round_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub outputs: ::prost::alloc::vec::Vec<SweepableOutput>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ScheduledSessionConfig {
    #[prost(int64, tag = "1")]
    pub start_time: i64,
    #[prost(int64, tag = "2")]
    pub end_time: i64,
    #[prost(int64, tag = "3")]
    pub period: i64,
    #[prost(int64, tag = "4")]
    pub duration: i64,
    #[prost(int64, tag = "5")]
    pub round_min_participants_count: i64,
    #[prost(int64, tag = "6")]
    pub round_max_participants_count: i64,
    #[prost(message, optional, tag = "7")]
    pub fees: ::core::option::Option<FeeInfo>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IntentInput {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub vout: u32,
    #[prost(uint64, tag = "3")]
    pub amount: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntentInfo {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub created_at: i64,
    #[prost(message, repeated, tag = "3")]
    pub receivers: ::prost::alloc::vec::Vec<Output>,
    #[prost(message, repeated, tag = "4")]
    pub inputs: ::prost::alloc::vec::Vec<IntentInput>,
    #[prost(message, repeated, tag = "5")]
    pub boarding_inputs: ::prost::alloc::vec::Vec<IntentInput>,
    #[prost(string, repeated, tag = "6")]
    pub cosigners_public_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "7")]
    pub intent: ::core::option::Option<Intent>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Output {
    /// Amount to send in satoshis.
    #[prost(uint64, tag = "3")]
    pub amount: u64,
    #[prost(oneof = "output::Destination", tags = "1, 2")]
    pub destination: ::core::option::Option<output::Destination>,
}
/// Nested message and enum types in `Output`.
pub mod output {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Destination {
        #[prost(string, tag = "1")]
        VtxoScript(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        OnchainAddress(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Conviction {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "ConvictionType", tag = "2")]
    pub r#type: i32,
    #[prost(int64, tag = "3")]
    pub created_at: i64,
    /// 0 if never expires
    #[prost(int64, tag = "4")]
    pub expires_at: i64,
    #[prost(bool, tag = "5")]
    pub pardoned: bool,
    /// Only set for script convictions
    #[prost(string, tag = "6")]
    pub script: ::prost::alloc::string::String,
    #[prost(enumeration = "CrimeType", tag = "7")]
    pub crime_type: i32,
    #[prost(string, tag = "8")]
    pub round_id: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CrimeType {
    Unspecified = 0,
    Musig2NonceSubmission = 1,
    Musig2SignatureSubmission = 2,
    Musig2InvalidSignature = 3,
    ForfeitSubmission = 4,
    ForfeitInvalidSignature = 5,
    BoardingInputSubmission = 6,
    ManualBan = 7,
}
impl CrimeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CRIME_TYPE_UNSPECIFIED",
            Self::Musig2NonceSubmission => "CRIME_TYPE_MUSIG2_NONCE_SUBMISSION",
            Self::Musig2SignatureSubmission => "CRIME_TYPE_MUSIG2_SIGNATURE_SUBMISSION",
            Self::Musig2InvalidSignature => "CRIME_TYPE_MUSIG2_INVALID_SIGNATURE",
            Self::ForfeitSubmission => "CRIME_TYPE_FORFEIT_SUBMISSION",
            Self::ForfeitInvalidSignature => "CRIME_TYPE_FORFEIT_INVALID_SIGNATURE",
            Self::BoardingInputSubmission => "CRIME_TYPE_BOARDING_INPUT_SUBMISSION",
            Self::ManualBan => "CRIME_TYPE_MANUAL_BAN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CRIME_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CRIME_TYPE_MUSIG2_NONCE_SUBMISSION" => Some(Self::Musig2NonceSubmission),
            "CRIME_TYPE_MUSIG2_SIGNATURE_SUBMISSION" => Some(Self::Musig2SignatureSubmission),
            "CRIME_TYPE_MUSIG2_INVALID_SIGNATURE" => Some(Self::Musig2InvalidSignature),
            "CRIME_TYPE_FORFEIT_SUBMISSION" => Some(Self::ForfeitSubmission),
            "CRIME_TYPE_FORFEIT_INVALID_SIGNATURE" => Some(Self::ForfeitInvalidSignature),
            "CRIME_TYPE_BOARDING_INPUT_SUBMISSION" => Some(Self::BoardingInputSubmission),
            "CRIME_TYPE_MANUAL_BAN" => Some(Self::ManualBan),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConvictionType {
    Unspecified = 0,
    Script = 1,
}
impl ConvictionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONVICTION_TYPE_UNSPECIFIED",
            Self::Script => "CONVICTION_TYPE_SCRIPT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONVICTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CONVICTION_TYPE_SCRIPT" => Some(Self::Script),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod admin_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct AdminServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdminServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdminServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AdminServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AdminServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get_scheduled_sweep(
            &mut self,
            request: impl tonic::IntoRequest<super::GetScheduledSweepRequest>,
        ) -> std::result::Result<tonic::Response<super::GetScheduledSweepResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.AdminService/GetScheduledSweep");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "GetScheduledSweep"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_round_details(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRoundDetailsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRoundDetailsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.AdminService/GetRoundDetails");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "GetRoundDetails"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_rounds(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRoundsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRoundsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.AdminService/GetRounds");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "GetRounds"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_note(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateNoteRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateNoteResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.AdminService/CreateNote");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "CreateNote"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_scheduled_session_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetScheduledSessionConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetScheduledSessionConfigResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ark.v1.AdminService/GetScheduledSessionConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.AdminService",
                "GetScheduledSessionConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_scheduled_session_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateScheduledSessionConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateScheduledSessionConfigResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ark.v1.AdminService/UpdateScheduledSessionConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.AdminService",
                "UpdateScheduledSessionConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_intents(
            &mut self,
            request: impl tonic::IntoRequest<super::ListIntentsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListIntentsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.AdminService/ListIntents");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "ListIntents"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_intents(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIntentsRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteIntentsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.AdminService/DeleteIntents");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "DeleteIntents"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_convictions(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConvictionsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetConvictionsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.AdminService/GetConvictions");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "GetConvictions"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_convictions_in_range(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConvictionsInRangeRequest>,
        ) -> std::result::Result<tonic::Response<super::GetConvictionsInRangeResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.AdminService/GetConvictionsInRange");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.AdminService",
                "GetConvictionsInRange",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_convictions_by_round(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConvictionsByRoundRequest>,
        ) -> std::result::Result<tonic::Response<super::GetConvictionsByRoundResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.AdminService/GetConvictionsByRound");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.AdminService",
                "GetConvictionsByRound",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_active_script_convictions(
            &mut self,
            request: impl tonic::IntoRequest<super::GetActiveScriptConvictionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetActiveScriptConvictionsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ark.v1.AdminService/GetActiveScriptConvictions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.AdminService",
                "GetActiveScriptConvictions",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn pardon_conviction(
            &mut self,
            request: impl tonic::IntoRequest<super::PardonConvictionRequest>,
        ) -> std::result::Result<tonic::Response<super::PardonConvictionResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.AdminService/PardonConviction");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "PardonConviction"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn ban_script(
            &mut self,
            request: impl tonic::IntoRequest<super::BanScriptRequest>,
        ) -> std::result::Result<tonic::Response<super::BanScriptResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.AdminService/BanScript");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "BanScript"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn revoke_auth(
            &mut self,
            request: impl tonic::IntoRequest<super::RevokeAuthRequest>,
        ) -> std::result::Result<tonic::Response<super::RevokeAuthResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.AdminService/RevokeAuth");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "RevokeAuth"));
            self.inner.unary(req, path, codec).await
        }
    }
}
